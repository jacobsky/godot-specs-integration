use specs::prelude::*;
use specs_derive::*;
use gdnative::prelude::*;
use gdnative::api::{ShaderMaterial, Texture};

#[derive(Debug, Default, Component, ToVariant)]
#[storage(NullStorage)]
pub struct Player;


#[derive(Debug, Component, ToVariant)]
pub struct ShaderParams {
    pub (crate) fg: Color,
    pub (crate) bg: Color,
}

impl ShaderParams {
    pub fn new(fg: Color, bg: Color) -> Self {
        Self { fg, bg }
    }
}

impl Default for ShaderParams {
    fn default() -> Self {
        Self::new(
            Color::from_rgb(1.0, 1.0, 1.0), 
            Color::from_rgba(0.0, 0.0, 0.0, 0.0)
        )
    }
}

/// Texture override can be used to temporarily override the texture of an object without fully replacing it.
#[derive(Debug, Component)]
pub struct TextureOverride {
    pub (crate) texture: Ref<Texture>,
}

/// This is the ECS version of the CanvasItem class used by Godot.
/// This item tracks the rid used by the `VisualServer` this only works as a reference to the Rid and management must be done manually by the Godot `CanvasItem` class or managed by a system that can set them.
/// `rid` this rid must be generated by `VisualServer::canvas_item_create()` is expected to be retrieved by the visual server and is safe for sharing among all references.
/// `parent_rid` is optional and when set with `VisualServer::canvas_item_set_parent()`
/// `texture` is an optional reference that can be used to ensure that the Godot Texture Resource does not get freed while this canvas_item is referencing it.
#[derive(Debug, Component)]
pub struct CanvasItem {
    // The Rid for this canvas_item
    pub (crate) rid: Rid,
    // Represents the canvas where this exists.
    // This can be useful if you want to have a canvas item be possible swap canvases
    pub (crate) canvas_rid: Option<Rid>,
}

// Optional: Implement drop for CanvasItem
// If you choose to bypass the scene system entirely, it may be worth considering whether to use the following `Drop` implementation.
// In Godot, the rid is created and freed by the `CanvasItem` Constructor and Destructor respectively.
// As this approach bypasses the SceneTree entirely, it may be safer to also implement drop directly so that entity deletion will always result in freeing the Rid.
// Note: This approach will be less performance than using a system to free them manually, but it may be safer depending upon your architecture.
// This should be reviewed before using the same process in your own games.
// Link to Godot CanvasItem source code: https://github.com/godotengine/godot/blob/3.x/scene/2d/canvas_item.cpp#L1260 
// impl Drop for CanvasItem {
//     fn drop(&mut self) {
//         let vs = unsafe { VisualServer::godot_singleton() };
//         vs.free_rid(self.rid);
//     }
// }
#[derive(Debug, Component)]
pub struct CanvasItemTexture {
    pub (crate) texture: Ref<Texture>,
}
#[derive(Debug, Component)]
pub struct CanvasItemShader {
    pub (crate) material: Ref<ShaderMaterial>
}

pub fn register_components(world: &mut World) {
    world.register::<Player>();
    world.register::<CanvasItem>();
    world.register::<CanvasItemTexture>();
    world.register::<CanvasItemShader>();
    world.register::<ShaderParams>();
    world.register::<TextureOverride>();
}