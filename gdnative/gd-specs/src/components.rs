use specs::prelude::*;
use specs_derive::*;
use gdnative::prelude::*;
use gdnative::api::{VisualServer, ShaderMaterial, Texture};

#[derive(Debug, Default, Component, ToVariant)]
#[storage(NullStorage)]
pub struct Player;


#[derive(Debug, Component, ToVariant)]
pub struct ShaderParams {
    pub (crate) fg: Color,
    pub (crate) bg: Color,
}

impl ShaderParams {
    pub fn new(fg: Color, bg: Color) -> Self {
        Self { fg, bg }
    }
}

impl Default for ShaderParams {
    fn default() -> Self {
        Self::new(
            Color::from_rgb(1.0, 1.0, 1.0), 
            Color::from_rgba(0.0, 0.0, 0.0, 0.0)
        )
    }
}

#[derive(Debug, Component)]
pub struct TextureOverride {
    pub (crate) texture: Ref<Texture>,
}

/// This is the ECS version of the CanvasItem class used by Godot.
/// This type is not considered to be Clone safe. It represents a unique resource used by the VisualServer that needs to ensure it has been freed once deleted.
/// `rid` this rid must be generated by `VisualServer::canvas_item_create()` is expected to be retrieved by the visual server and is safe for sharing among all references.
/// `parent_rid` is optional and when set with `VisualServer::canvas_item_set_parent()`
/// `texture` is an optional reference that can be used to ensure that the Godot Texture Resource does not get freed while this canvas_item is referencing it.
#[derive(Debug, Component)]
pub struct CanvasItem {
    pub (crate) rid: Rid,
    pub (crate) parent_rid: Option<Rid>,
    pub (crate) texture: Option<Ref<Texture>>
}

// Why is `Drop` implemented?
// In this particular architecture, CanvasItem takes the place of the Node2D (which inherits from CanvasItem) that would normally hold the Rid for the canvas item.
// In Godot, the rid is created and freed in the Constructor and Destructor, while it may be possible to do eventing, I feel that this is the safest option when managing the system resources.
// If deleting entities does no need to account for any additional tasks.
// This should be reviewed before using the same process in your own games.
// Godot CanvasItem source code: https://github.com/godotengine/godot/blob/3.x/scene/2d/canvas_item.cpp#L1260 

impl Drop for CanvasItem {
    fn drop(&mut self) {
        let vs = unsafe { VisualServer::godot_singleton() };
        vs.free_rid(self.rid);
    }
}

#[derive(Debug, Component)]
pub struct CanvasItemMaterial {
    pub (crate) material: Ref<ShaderMaterial>
}

pub fn register_components(world: &mut World) {
    world.register::<CanvasItem>();
    world.register::<CanvasItemMaterial>();
    world.register::<TextureOverride>();
    world.register::<Player>();
    world.register::<ShaderParams>();
    world.register::<TextureOverride>();
}